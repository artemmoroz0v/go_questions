# Вопросы по Golang

### 1. Как реализовано ООП в Go?
 В Go нет классической реализация ООП, так как он не является в привычном понимании объектно-ориентированным языком. Однако в Go есть свои приближения к этой реализации.

### 2. Как реализована инкапсуляция в Go?
Инкапсуляция в Go реализована по "правилу первой буквы". Нижний регистр первой буквы будет означать, что переменная, функция или метод доступна только в рамках пакета. Тогда как верхний регистр даст доступ к переменной, функции или методу за рамками пакета.

### 3. Как реализован полиморфизм в Go?
Полиморфизм в Go реализован при помощи интерфейсов. Основная идея состоит в том, что мы можем работать со множеством типов, реализующих интерфейс, как с единым интерфейсным типом.

### 4. Как реализовано наследование в Go?
В Go как такового наследования нет, однако есть понятие "встраивание". Встраивание - процесс, когда мы одну структуру включаем в другую структуру. При этом методы дочерних структур родительская структура также будет наследовать.

### 5. Что будет, если и в родительской и дочерней структуре есть реализация методов с одинаковым названием?
Реализация родительского метода будет переписана реализацией дочернего метода.

### 6. Что такое пакеты в Go?
Пакет - это механизм переиспользования кода, при котором go файлы помещаются в общую директорию. В рамках пакета все функции и глобальные переменные, объявленные как в верхнем, так и в нижнем регистре, видят друг друга.

### 7. Что такое глобальная переменная?
Глобальная переменная - это переменная уровня пакета, то есть объявленная вне функции. "Правило первой буквы" также распространяется и на глобальную переменную: в случае верхнего регистра она будет доступна за рамками пакета, в случае нижнего регистра - нет.

### 8. Можно ли выполнить несколько условий в одном объявленном операторе switch-case?
Можно, благодаря ключевому слову ***fallthrough***. Оно заставляет выполнять код в следующей объявленной булевой секции, вне зависимости подходит ли булевое условие case этой секции.

### 9. Что представляют из себя строки в Go?
Строки в Go - структура, состоящая из двух полей: указатель на массив байтов и целого числа, обозначающего длину строки. Исходя из этого можно сказать, что в Go ***строка - массив байтов***. 

### 10. Можно ли менять строки в Go?
Нет, в Go нельзя изменять строки, так как они составляются из символов Unicode и являются неизменяемыми последовательностями, т.е. порядок этой последовательности нельзя изменить.

### 11. Как определить длину строки? Какие нюансы есть при итерировании по строке?
Исходя из того же знания, что строка это массив байт, взяв базовую функцию len() от строки мы получим количество байт. При итерации по строке мы будем итерироваться по байтам. Однако в зависимости от кодировки, символ в строке может занимать не один байт.
Чтобы понять это лучше, возьмём строчку, состоящую, например, из иероглифов: ***"世界, 你好!"***. Если мы захотим узнать ее размер, то при вызове функции ***len*** получим число 15, исходя из описанных выше соображений. Однако если мы возьмем ***len*** от этой строки, предварительно сконвертировав ее в руны, то получим ожидаемый нами ответ - 7. Именно 7 символов в нашей строке с иероглифами.
Можно сказать, что при итерации по строке через, например, ***range***, в индексе мы получим некое "смещение" количества байтов, а в значении - сами байты.

### 12. Какие численные типы есть в Go?
- int/int8/int16/int32/int64;
- uint/uint8/uint16/uint32/uint64;
- float32/float64;
- complex64/complex128;
- rune (псевдоним int32) - кодовое целое число для символа

### 13. Какие есть нюансы у int? 
В зависимости от того, какая архитектура платформы, на которой мы стартуем, компилятор преобразует int в int32 для 32-разрядной архитектуры и в int64 для 64-разрядной архитектуры.

### 14. Как преобразовать строку в int и наоборот?
Только при помощи специального пакета strconv. Стандартное приведение типов наподобие string(int) и int(string), как было в С++, не работает в Go.

### 15. Какой результат получим если разделить int на 0 и float на 0?
Деление int на 0 в go невозможно и вызовет ошибку компилятора. Тогда как деление float на 0 дает в своем результате бесконечность (Inf).

### 16. Что такое iota?
iota - идентификатор, который позволяет создавать последовательные не типизированные целочисленные константы. Значением iota является индекс ConstSpec. Не смотря на то, что первым индексом является 0, значение первой константы можно задать отличным от 0, что в свою очередь повлияет на значения последующих констант.

### 17. Что такое слайс, каковы его отличия от массива?
Если массив - это последовательно выделенная область памяти, причем размер массива постоянен и не может изменяться, то слайс в свою очередь - это надстройка над массивом. Слайс - это ***структура***, состоящая из трех полей: ***указатель на массив элементов(unsafe.Pointer)***, ***текущий размер слайса***, ***его вместимость***. По умоланию до значения 256 вместимость слайса увеличивается в 2 раза при равенстве с текущим размером, однако при значениях, >= 256, наша вместимость увеличивается в соответствии со следующей формулой, описанной в функции ***growslice()***: ***capacity += (capacity + 3 * threshold) / 4***, где ***treshold*** - константная переменная в функции, равная 256.

### 18. Как работает базовая функция append в Go?
Append добавляет элемент в слайса, расширяя его за пределы его len и возвращая при этом новый слайс. Если количество элементов, которые мы добавляем в слайс, не будет превышать его вместимость, вернется новый слайс, который ссылается на тот же базовый массив, что и предыдущий слайс. Если количество добавляемых элементов превысит вместимость, то вернется новый слайс, базовым для которого будет новый массив.

### 19. Можно ли указать переменную как размер массива?
Нет, размер массива всегда нужно указывать конкретным значением. Если мы в квадратных скобках укажем переменную, у нас будет ошибка компиляции.

### 20. Что такое map в Go?
Map в Go - это хэш-таблица, то есть структура, реализующая операции хэширования. При этом map - ссылочный тип, его надо инициализировать при создании.

### 21. В чем особенность map в Go, ее преимущество?
Преимущество map в Go в том, что в основные операции в ней выполняются в среднем за константное время. Это обусловлено тем, что map, как было упомянуто ранее, реализована на основе хэш-таблицы. Идея в том, что мы разбиваем все наши данные на небольшие группы с фиксированным размером (8), которые называются бакетами(см. пункт 21). 
Константное время основных операций мы получаем из-за того, что всегда нужно перебрать константное количество значений в каком-то конкретном бакете. При этом сама хэш-функция, вызов которой используется при работе с map, должна быть:
- равномерной (значения должны быть равномерно распределены по бакетам)
- быстрой
- детерминированной (для одного и того же ключа возвращается один и тот же номер бакета)
- криптоустойчивой (не должна позволять условным злоумышленникам подобрать ключи таким образом, чтобы все данные попали в один и тот же бакет)

### 22. Как реализована map в Go?
Map в Go - это указатель на структуру, содержащую в себе 9 полей, главными из которых являются: 
- размер Map
- количество бакетов ***B***, хранящееся в виде логарифма, чтобы оптимизировать память и ускорить побитовые операции
- параметр безопасности Map - ***hash seed***, позволяющий заполнять одни бакеты больше, чем другие, воизбежание подбора ключей
- указатель на массив бакетов размера 2^B, где B - двоичный логарифм от количества бакетов
- указатель на массив старых бакетов
В каждом бакете хранятся дополнительные 8 слотов для старших битов хэша, чтобы проверить наличие ключа сначала по ним, а потом уже непосредственно по полноценным хэшам в бакете. Так как если среди 8 слотов нет нужного нам, то нет смысла далее сверять все ключи.

### 23. Что может быть ключом, а что может быть значением в map?
Значением в map может быть все, что угодно, а ключом могут быть только ***сравниваемые типы***. Это значит, что ключом в мапе не может быть мапа, слайс, функция, либо структура, содержащая один из перечисленных типов.

### 24. Что такое эвакуация, и в каком случае она будет происходить?
Эвакуация - это процесс переноса значений map из одной области памяти в другую. Это происходит из-за того, что число значений в каждом отдельном bucket максимально равно 8. В тот момент времени, когда среднее количество значений в bucket составляет 6.5, Go понимает, что размер map не удовлетворяет необходимому. Начинается процесс расширения map - создается новый список бакетов, размером в два раза больше, чем предыдущий, а данные из старых бакетов будут скопированы в новые. Процесс эвакуации может происходить некоторое время, на протяжении которого новые и старые данные будут связаны, то есть при условном поиске в мапе мы будем смотреть и в старые бакеты, и в новые, что, кстати, порядком замедляет время работы.
Стоит также отметить, что эвакуации данных не происходит, когда мы явно указываем вместимость нашей мапы вторым параметром при инициализации через ***make***.

### 25. Какие есть особенности синтаксиса получения и записи значений в map?
Получить значение из map, которую мы предварительно не аллоцировали нельзя, приложение упадет в панику. Нужно создавать map при помощи make, то есть выделять и инициализировать память.
Если ключ не найден в map, в ответ мы получим дефолтное значение для типа значений map. То есть, для строки - это будет пустая строка, для int - 0, и так далее. Для того, чтобы точно понять, что в map действительно есть значение, хранящееся по переданному ключу, необходимо возвращать не только само значение, но и булевую переменную, которая показывает, удалось ли получить значение по ключу.

### 26. Как происходит поиск по ключу в map?
- вычисляется хэш от ключа;
- с помощью значения хэша вычисляется используемый для хранения bucket;
- вычисляется дополнительный хэш - это первые 8 бит уже полученного хэша;
- в полученном bucket последовательно сравнивается каждый из 8 его дополнительных хэшей с дополнительным хэшем ключа;
- если дополнительные хэши совпали, то получаем ссылку на значение и возвращаем его;
- если дополнительные хэши не совпали, и в bucket больше нет дополнительных хэшей, алгоритм переходит в следующий bucket, ссылка на который хранится в текущем;
- если в текущем bucket нет ссылки на следующий bucket, а значение так и не найдено, возвращается дефолтное значение.

### 27. Почему порядок обхода map всегда случайный?
Это связано с тем, что итератор, перебирающий значения, ходит и по старым, и по новым бакетам (если происходила эвакуация). Получается такая ситуация, что порядок следования элементов зависит от очень большого количества факторов: какая хэш-функция использовалась, какой размер мапы, происходила ли эвакуация и т.д...

### 28. Можно ли брать ссылку на значение, хранящееся по ключу в map?
Нельзя. Как раз-таки из-за вышеупомянутой эвакуации может получиться, что значения, хранящиеся в определённой ячейке памяти в текущий момент времени, в следующий момент времени уже могут там не храниться.

### 29. Может ли перебор по слайсу работать быстрее, чем по мапе?
Да, в теории такое возможно. Связано это с тем, что слайс не использует кэши, в нем есть только адресная арифметика. В случае же с мапой мы работаем со многими другими сущностями, которые могут замедлять нам перебор. Например, вызов той же хэш-функции.

### 30. Что такое интерфейс?
Интерфейс - некое соглашение (контракт), что тот или иной объект будет реализовывать указанное в интерфейсе поведение. Говоря проще, интерфейс - это структура, в которой описаны методы. Мы говорим, что структура удовлетворяет интерфейсу, когда она реализует все методы, описанные в нём.

### 31. Как выглядит интерфейс "под капотом"?
Интерфейс реализован, как структура, которая содержит в себе указатель на область памяти, в которой расположен объект, преобразовавшийся в интерфейсный тип, и указатель на структуру ***itab***, которая предоставляет служебную информацию об интерфейсе и базовом типе.

### 32. Что такое пустой интерфейс?
Исходя из определения интерфейса, пустой интерфейс - это интерфейс, для реализации которого не нужно описывать ни одного метода. Таким образом, пустому интерфейсу соответствует абсолютно любой тип. В этом и заключается его своеобразная магия в языке.

### 33. Что такое nil интерфейс?
Когда интерфейс nil - это значит, что интерфейс не ссылается на какое-либо значение, но при этом содержит в себе служебную информацию поля itab. По этой причине булево сравнение nil с интерфейсом всегда ложное.

### 34. Как определить тип интерфейса?
С помощью инструкции switch-case можно определить тип интерфейса, указав возможные варианты базового типа его значения.

### 35. Можно ли в функции ввести дополнительный блок скобок {...}?
Да, можно. Это связано с тем, что очень большую функцию довольно сложно декомпозировать.

### 36. Что такое receiver в Go?
***Receiver*** в Go - это аналог ***this*** в С++ - указатель на текущий объект данного класса.

### 37. Что такое выравнивание памяти?
Выравнивание - средство, с помощью которого можно уменьшить потребление памяти для хранения данных во время работы самой программы, т. е. оптимизировать структуры.
Выравнивание ускоряет доступ к памяти, генерируя код, который требует по одной инструкции для чтения и записи данных в ячейку памяти. Отсутствие выравнивания чревато возникновением ситуации, когда процессору приходится использовать уже не одну, а две или большее количество инструкций для доступа к данным, расположенным между адресами, кратными размеру машинного слова.

### 38. Как можно пользоваться выравниваем в Go?
Рассмотрим следующую структуру:

type Foo struct {

aaa bool // 1 по умолчанию. Но с заполнением - 4.

bbb int32 // 4 как максимальное в этой структуре.

ссс bool // 1 по умолчанию. Но с заполнением - 4. 

}

Суммарный вес этой структуры равен 12. Если в языке С используется термин «машинное слово», размер которого соответствует 4 или 8 байтам (в зависимости от разрядности процессора компьютера — 32 или 64), то в Go используется «требуемое выравнивание». Его значение равно размеру памяти, требующемуся самому большому полю в структуре.
