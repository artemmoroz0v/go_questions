# Вопросы по Golang

### 1. Как реализовано ООП в Go?
 В Go нет классической реализация ООП, так как он не является в привычном понимании объектно-ориентированным языком. Однако в Go есть свои приближения к этой р  реализации.

### 2. Как реализовано наследование в Go?
В Go как такового наследования нет, однако есть понятие "встраивание". Встраивание - процесс, когда мы одну структуру включаем в другую структуру. При этом методы дочерних структур родительская структура также будет наследовать.

### 3. Что будет, если и в родительской и дочерней структуре есть реализация методов с одинаковым названием?
Реализация родительского метода будет переписана реализацией дочернего метода.

### 4. Как реализована инкапсуляция в Go?
Инкапсуляция в Go реализована по "правилу первой буквы". Нижний регистр первой буквы будет значить, что переменная, функция или метод доступна только в рамках пакета. Тогда как верхний регистр даст доступ к переменной, функции или методу за рамками пакета.

### 5. Как реализован полиморфизм в Go?
Полиморфизм в Go реализован при помощи интерфейсов. Основная идея состоит в том, что мы можем работать со множеством типов, реализующих интерфейс, как с единым интерфейсным типом.

### 6. Что такое пакеты в Go?
Пакет - это механизм переиспользования кода, при котором go файлы помещаются в общую директорию. В рамках пакета все функции и глобальные переменные, объявленные как в верхнем, так и в нижнем регистре, видят друг друга.

### 7. Что такое глобальная переменная?
Глобальная переменная - это переменная уровня пакета, то есть объявленная вне функции. "Правило первой буквы" также распространяется и на глобальную переменную: в случае верхнего регистра она будет доступна за рамками пакета, в случае нижнего регистра - нет.

### 8. Можно ли выполнить несколько условий в одном объявленном операторе switch-case?
Можно, благодаря ключевому слову ***fallthrough***. Оно заставляет выполнять код в следующей объявленной булевой секции, вне зависимости подходит ли булевое условие case этой секции.

### 9. Что представляют из себя строки в Go?
Строки в Go - структура, состоящая из двух полей: указатель на массив байтов и целого числа, обозначающего длину строки. Исходя из этого можно сказать, что в Go ***строка - массив байтов***. 

### 10. Можно ли менять строки в Go?
Нет, в Go нельзя изменять строки, так как они составляются из символов Unicode и являются неизменяемыми последовательностями, т.е. порядок этой последовательности нельзя изменить.

### 11. Как определить длину строки? Какие нюансы есть при итерировании по строке?
Исходя из того же знания, что строка это массив байт, взяв базовую функцию len() от строки мы получим количество байт. При итерации по строке мы будем итерироваться по байтам. Однако в зависимости от кодировки, символ в строке может занимать не один байт.

### 12. Какие численные типы есть в Go?
- int/int8/int16/int32/int64;
- uint/uint8/uint16/uint32/uint64;
- float32/float64;
- complex64/complex128;
- rune

### 13. Какие есть нюансы у int? 
В зависимости от того, какая архитектура платформы, на которой мы стартуем, компилятор преобразует int в int32 для 32-разрядной архитектуры и в int64 для 64-разрядной архитектуры.

### 14. Как преобразовать строку в int и наоборот?
Только при помощи специального пакета strconv. Стандартное приведение типов а-ля string(int) и int(string), как было в С++, не работает в Go.

### 15. Какой результат получим если разделить int на 0 и float на 0?
Деление int на 0 в go невозможно и вызовет ошибку компилятора. Тогда как деление float на 0 дает в своем результате бесконечность (Inf).

### 16. Что такое iota?
iota - идентификатор, который позволяет создавать последовательные не типизированные целочисленные константы. Значением iota является индекс ConstSpec. Не смотря на то, что первым индексом является 0, значение первой константы можно задать отличным от 0, что в свою очередь повлияет на значения последующих констант.

### 17. Что такое слайс, каковы его отличия от массива?
Если массив - это последовательно выделенная область памяти, причем размер массива постоянен и не может изменяться, то слайс в свою очередь - это надстройка над массивом. Слайс - это ***структура***, состоящая из трех полей: ***указатель на массив элементов(unsafe.Pointer)***, ***текущий размер слайса***, ***его вместимость***. По умоланию вместимость слайса увеличивается в 2 раза при равенстве с текущим размером, однако есть метод ***growslice()***, который работает по определенному алгоритму начиная с очень больших значений вместимости в целях экономии памяти. (увеличение в четверть от базовой ёмкости)

### 18. Как работает базовая функция append в Go?
Append добавляет элемент в слайса, расширяя его за пределы его len и возвращая при этом новый слайс. Если количество элементов, которые мы добавляем в слайс, не будет превышать его вместимость, вернется новый слайс, который ссылается на тот же базовый массив, что и предыдущий слайс. Если количество добавляемых элементов превысит вместимость, то вернется новый слайс, базовым для которого будет новый массив.

### 19. Что такое map в Go?
Map в Go - это хэш-таблица, то есть структура, реализующая операции хэширования. При этом map - ссылочный тип, его надо инициализировать при создании. Преимущество map в том, что среднее время выполнения основных операций - O(1). 

### 20. Как реализована map в Go?


### 21. Что может быть ключом, а что может быть значением в map?
Значением в map может быть все, что угодно, а ключом могут быть только ***сравниваемые типы***. Это значит, что ключом в мапе не может быть мапа, слайс, функция, либо структура, содержащая один из перечисленных типов.

### 22. Что такое эвакуация, и в каком случае она будет происходить?
Эвакуация - это процесс переноса значений map из одной области памяти в другую. Это происходит из-за того, что число значений в каждом отдельном bucket максимально равно 8. В тот момент времени, когда среднее количество значений в bucket составляет 6.5, Go понимает, что размер map не удовлетворяет необходимому. Начинается процесс расширения map. Процесс эвакуации может происходить некоторое время, на протяжении которого новые и старые данные будут связаны.

### 23. Можно ли брать ссылку на значение, хранящееся по ключу в map?
Нельзя. Из-за эвакуации может получиться, что значения, хранящиеся в определённой ячейки памяти в текущий момент времени, в следующий момент времени уже могут там не храниться.

### 24. Какие есть особенности синтаксиса получения и записи значений в map?
Получить значение из map, которую мы предварительно не аллоцировали нельзя, приложение упадет в панику. Нужно создавать map при помощи make, то есть выделять и инициализировать память.
Если ключ не найден в map в ответ мы получим дефолтное значение для типа значений map. То есть, для строки - это будет пустая строка, для int - 0, и так далее. Для того, чтобы точно понять, что в map действительно есть значение, хранящееся по переданному ключу, необходимо возвращать не только само значение, но и булевую переменную, которая показывает, удалось ли получить значение по ключу.
